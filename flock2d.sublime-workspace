{
	"auto_complete":
	{
		"selected_items":
		[
			[
<<<<<<< HEAD
				"i",
				"i"
=======
				"pars",
				"parsArray"
			],
			[
				"tr",
				"trays"
			],
			[
				"it",
				"itTot"
			],
			[
				"rt",
				"return"
			],
			[
				"dists",
				"distsFile"
			],
			[
				"S",
				"StatsTool"
			],
			[
				"Wr",
				"WriteLine"
>>>>>>> FETCH_HEAD
			],
			[
				"for",
				"for	for â€¦ done"
			],
			[
				"geometr",
				"geometrico"
			],
			[
				"f",
				"f"
			],
			[
				"Al",
				"AlignVels"
			],
			[
				"prom",
				"prom_geom"
			],
			[
				"st_",
				"st_adjacen"
			],
			[
				"st",
				"st_mat_dist"
			],
			[
				"W",
				"WriteLine"
			],
			[
				"dist",
				"dists"
			],
			[
				"dis",
				"dists"
			],
			[
				"st_d",
				"st_dist_R"
			],
			[
				"num",
				"num_bin"
			],
			[
				"e",
				"epsilon"
			],
			[
				"nu",
				"num_bin"
			],
			[
				"w",
				"WriteLine"
			],
			[
				"Calc",
				"CalcDistR"
			],
			[
				"Di",
				"Dist"
			],
			[
				"FOR",
				"foreach"
			],
			[
				"psi",
				"psi_inst"
			],
			[
				"vel",
				"vel_prom"
			],
			[
				"ang_",
				"ang_topo"
			],
			[
				"ang",
				"ang_geom"
			],
			[
				"sq",
				"sqrt	sqrt"
			],
			[
				"ata",
				"atan2	atan2"
			],
			[
				"bac",
				"bac"
			],
			[
				"prom_",
				"prom_topo"
			],
			[
				"ligh",
				"light	lights"
			],
			[
				"upd",
				"updateSize"
			],
			[
				"sp",
				"sphere	sphere"
			],
			[
				"backgr",
				"background	background grey alpha"
			],
			[
				"he",
				"height"
			],
			[
				"ke",
				"key	key"
			],
			[
				"key",
				"key	keyPressed"
			],
			[
				"r",
				"r"
			],
			[
				"println",
				"println	println var"
			],
			[
				"el",
				"ellipse	ellipse"
			],
			[
				"an",
				"angleBetween"
			],
			[
				"print",
				"println	println var"
			],
			[
				"Agent",
				"Agent2D"
			],
			[
				"lin",
				"link	link"
			],
			[
				"flo",
				"flock"
			],
			[
				"random",
				"random2D"
			],
			[
				"rand",
				"random	random"
			],
			[
				"stro",
				"stroke	stroke grey"
			],
			[
				"no",
				"nofill	noFill"
			],
			[
				"si",
				"size	size"
			],
			[
				"se",
				"setup	setup"
			],
			[
				"st_da",
				"st_data1"
			],
			[
				"N",
				"Norm"
			],
			[
				"p",
				"pos"
			],
			[
				"D",
				"Dist"
			],
			[
				"Pr",
				"Print_vel"
			],
			[
				"d",
				"dot"
			],
			[
				"else",
				"else	Else"
			],
			[
				"re",
				"return"
			],
			[
				"A",
				"Acos"
			],
			[
				"T",
				"ToString"
			],
			[
				"C",
				"Console"
			],
			[
				"Ne",
				"NextSimDouble"
			],
			[
				"Con",
				"Console"
			],
			[
				"VE",
				"Vector3D"
			],
			[
				"this",
				"this"
			],
			[
				"Cr",
				"Cross"
			],
			[
				"Ve",
				"Vector3D"
			],
			[
				"Vec",
				"Vec_Quat"
			],
			[
				"n",
				"n"
			],
			[
				"Qua",
				"Quaternion"
			],
			[
				"v",
				"v"
			],
			[
				"m",
				"Members"
			],
			[
				"M",
				"Math"
			],
			[
				"V",
				"Vector3D"
			],
			[
				"retur",
				"return"
			],
			[
				"pu",
				"public"
			],
			[
				"li",
				"links"
			],
			[
				"S",
				"string"
			],
			[
				"L",
				"Length"
			]
		]
	},
	"buffers":
	[
		{
			"file": "StatsLib/StatsLib.cs",
			"settings":
			{
<<<<<<< HEAD
				"buffer_size": 3428,
=======
<<<<<<< HEAD
				"buffer_size": 3075,
=======
				"buffer_size": 3304,
>>>>>>> FETCH_HEAD
>>>>>>> f76f9e0127aeb8ffc4e9ef0397f08c651e63291d
				"line_ending": "Unix"
			}
		},
		{
			"file": "stat_test/Program.cs",
			"settings":
			{
<<<<<<< HEAD
				"buffer_size": 2033,
=======
<<<<<<< HEAD
				"buffer_size": 1197,
=======
				"buffer_size": 2009,
>>>>>>> f76f9e0127aeb8ffc4e9ef0397f08c651e63291d
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/PrintMethods/printing.cs",
			"settings":
			{
				"buffer_size": 5637,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# Manejo de los datos de la simulacion con Python\n# Libreria para automatizar\n# Martin Zumaya Hernandez 2014\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom pylab import *\nimport sys\n\nsys.setrecursionlimit(3000)\n\next = \".txt\" #Extension de los archivos de datos\ndists = \"dists/\" #Directorio con archivos de distancias\n\n########################################################\n\n# Obtiene parametros de archivo en el directorio path\n\ndef GetParams(path):\n\n	params = []\n\n	data = open(path + \"params.txt\",'rb')\n\n	for line in data.readlines():\n	    # print(repr(line.split()[0]) +\"\\t\"+ repr(line.split()[-1]))\n	    params.append(float(line.split()[-1]))\n\n	data.close()\n\n	return params\n\n########################################################\n\n# Obtiene matriz de distancias completa\ndef GetDists(path, t, N):\n\n	DD = [] #Arreglo para guradar distancias\n\n	ruta = path + dists + repr(t) + ext\n	# print(ruta)\n\n	data = open(ruta,'rb')\n\n	i = 0\n\n	for line in data.readlines():\n\n		# dd = []\n\n		vals = line.split()\n\n		# print(repr(len(vals))+\"\\n\")\n		# print(repr(i)+\"\\n\")\n\n		# for k in range(len(vals)):\n		for k in range(i+1,N):\n\n			# dd.append(float(vals[k]))\n			DD.append(float(vals[k]))\n\n		# DD.append(dd)\n\n		i += 1\n\n	# print(len(DD))\n\n	return DD\n\n########################################################\n\n# Calcula distribucion de distancias\ndef CalcHist(dists, num_bin):\n\n	bins = arange(1,num_bin+1) #Arreglo de bins\n	hist = zeros(num_bin) #inicializa el histograma\n\n	DD = []\n\n	j = 0\n\n	n = len(dists)\n\n	# print(n)\n\n	for i in range(n):\n\n	    for k in range(n-j):\n\n	        DD.append(dists[i][k])\n\n	    j += 1\n\n	DD.sort() #Ordena de menor a mayor\n\n	#print DD[0]\n	#print len(DD)\n\n	epsilon = DD[-1]/num_bin #Tamanio de cada bin en funcion del maximo\n\n	for d in DD:\n	    count = d/epsilon\n	    if count > 0: hist[int(count-1)] += 1.0 #contador de cada bin\n\n	# Calcula distancia promedio\n	r_prom = 0\n\n	# for i in range(int(num_bin)):\n	for i in range(int(num_bin)):\n\n		# r_prom += (epsilon*(i)*hist[i])/num_bin\n		# r_prom += epsilon*(i+1)*hist[i]\n		r_prom += epsilon*i*hist[i]\n\n	r_prom *= 1/num_bin\n\n	#Falta determinar bien el r mas probable\n\n	r_max = np.argmax(hist)*epsilon # distancia mas probable\n	std_dev = np.std(DD) #desviacion estandar\n\n	return [hist,r_prom,r_max,std_dev,epsilon,sum(hist)]\n\n########################################################\n########################################################\n\n# Calcula distribucion de distancias (version numpy)\n\ndef CalcHist1(dists, num_bin):\n\n	dists.sort() #Ordena de menor a mayor\n\n	#print dists[0]\n	#print len(dists)\n\n	epsilon = dists[-1]/num_bin #Tamanio de cada bin en funcion del maximo\n\n	# for d in dists:\n	#     count = d/epsilon\n	#     if count > 0: hist[int(count-1)] += 1.0 #contador de cada bin\n\n	hist = np.histogram(dists,num_bin, density = True)\n	# hist = np.histogram(dists,num_bin)\n\n	# Calcula distancia promedio\n	r_prom = 0\n\n	# for i in range(int(num_bin)):\n	for i in range(int(num_bin)):\n\n		# r_prom += (epsilon*(i)*hist[i])/num_bin\n		# r_prom += epsilon*(i+1)*hist[i]\n		# r_prom += epsilon*i*hist[0][i]\n		r_prom += np.diff(hist[1])[i]*i*hist[0][i]\n\n	# r_prom *= 1/num_bin\n\n	#Falta determinar bien el r mas probable\n\n	r_max = np.argmax(hist[0])*epsilon # distancia mas probable\n	std_dev = np.std(dists) #desviacion estandar\n\n	return [hist[0],r_prom,r_max,std_dev,epsilon,sum(hist[0]),hist[1]]\n\n########################################################\n\n# Calcula lista de adjacencia a partir de dists y r\ndef CalcAdjs(dists,r):\n\n	ADJ = [] #adjacencia toda la red\n\n	for i in range(len(dists)):\n\n		adj = [] #adjacencia particula i\n\n		adj.append(i)\n\n		for j in range(len(dists[i])):\n\n			if dists[i][j] > 0 and dists[i][j] <= r :\n\n				adj.append(j)\n\n		ADJ.append(adj)\n\n	return ADJ\n\n########################################################\n\n########################################################\n\n# Calcula lista de adjacencia a partir de dists y r\ndef CalcAdjs1(N,dists,r):\n\n	ADJ = [] #adjacencia toda la red\n\n	k = 0\n\n	for i in range(N):\n\n		adj = [] #adjacencia particula i\n\n		adj.append(i)\n\n		for j in range(i+1,N):\n\n			if dists[k] > 0 and dists[k] <= r :\n\n				adj.append(j)\n\n			k += 1\n\n		ADJ.append(adj)\n\n	return ADJ\n\n########################################################\n\n# Imprime lista de adjacencia\ndef PrintAdjs(adj):\n	for i in range(len(adj)):\n		print(adj[i])\n\n########################################################\n\n# Etiqueta los elementos de la vecindad\n\ndef set_label(U,i,c,label):\n\n	L = len(U[i]) # Accede a la vecindad de la part i\n\n	if L != 0: # Si la vecindad no es vacia\n\n		for j in range(L): # para los vecinos de...\n\n			k = U[i][j] # indice de vecino\n\n			# print (k)\n\n			if label[k] == 0:\n\n				label[k] = label[i]\n\n				set_label(U,k,c,label)\n\n########################################################\n\n# CLUSTERING RECURSIVO\n\ndef Cluster(neigh):\n\n	c = 1 # etiqueta de cluster inicial\n\n	for i in range(len(neigh)):\n\n		neigh[i].pop(0)\n\n		#print (neigh[i])\n\n	label = zeros(len(neigh)) # vector de etiquetas\n	cl_size = {} # diccionario: llave:cluster, valor:tamanio\n	#print (labels)\n\n	for i in range(len(neigh)):\n\n		if label[i] == 0:\n\n			cl_size[c] = 1\n\n			label[i] = c\n\n			# print (label)\n\n			set_label(neigh,i,c,label)\n\n			# print (label)\n		else: cl_size[label[i]] += 1\n\n		c += 1\n\n	# numero de clusters\n	NC = len(cl_size)\n\n	# indice mas alto\n	IM = max(cl_size)\n\n	# llaves\n	# sorted(cl_size.keys())\n	# valores\n	# sorted(cl_size.values())\n\n	# cluster mas grande\n	CM = sorted(cl_size.values())[-1]\n\n	# print (label)\n	return [label,cl_size,CM]\n",
			"file": "/home/martin/GitRepos/JuliaFlocks/PyData/LibData.py",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 5530,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# Manejo de los datos de la simulacion con Python\n# Libreria para automatizar\n# Martin Zumaya Hernandez 2014\n\nfrom LibData import *\nimport pylab\nimport sys\n# import numpy as np\n\n# Parametros de linea de comandos:\n# 1 -> conectividad\n\n# ruta a directorio principal, se identifica por f\n\nf = float(sys.argv[1]) #conectividad en funcion de fraccion de N\n\n#path = \"../data_f\"+ str(f) +\"/\"\n#path = \"../DATA/data_f\"+ str(f)+ \"_ro\"+str(p) +\"/\"\n# path = \"../GitRepos/DATA/data_f\"+ str(f) +\"/\"\n\npath = \"../../DATA/data_f\"+ str(f) +\"/\"\n\n# img_path = \"../../Grafs/con_r0\"\nimg_path = \"../../Grafs/con_rprom\"\n# img_path = \"../../Grafs/\"+ str(f) +\"/\"\n\n# print (path)\n\n# Estructura parametros:\n	# Particulas\n	# densidad\n	# radio\n	# f\n	# ruido geometrico\n	# ruido topologico\n	# peso geometrico\n	# regimen de velocidad\n	# iteraciones\n	# paso\n\n# obtiene parametros de archivo\nparams = GetParams(path)\n# print(params)\n\nN        = int(params[0]) #Numero de particulas\nro       = params[1] #Densidad\nr_0      = params[2] #Radio interaccion (vel_reg)\nf        = params[3] #Fraccion de N en largo alcance\nnoise_sh = params[4] #Ruido corto\nnoise_lg = params[5] #Ruido largo\nrel_weig = params[6] #Peso Relativo vecindades\nreg_vel  = params[7] #Regimen de velocidad\nt_f      = params[8] #iteraciones totales\nstep     = params[9] #frecuencia de muestreo\n\n# step    = 250 #frecuencia de muestreo (Se obtiene del archivo de params)\nnum_bin = 200\n\nbin_vec = arange(1,num_bin+1)\n\ntiempo = arange(1,t_f+step,step)\n\n# print(tiempo)\n\nit_tot = t_f/step #muestras totales\n# print(it_tot)\n\nmax_cls = [] # Para guardar clsuter mas grande\n\n# cls_data = open(img_path+\"cls_data\"+str(f)+\".dat\",'w')\ncls_data = open(img_path+\"/datos_clusters/cls_data\"+str(f)+\".txt\",'w')\n\nfor i in range(-1,int(it_tot)):\n\n	if i == -1:\n		j = 1\n	else:\n		j =	(i+1)*int(step)\n\n	# print(repr(j))\n\n	dists = GetDists(path,j,N) #obtiene distancias\n	# print(dists)\n\n	# hist = CalcHist(dists,num_bin) #calcula histograma\n	hist = CalcHist1(dists,num_bin) #calcula histograma\n\n	# print(hist[5])\n\n	print(str(f) + \"\\t\" + repr(j) + \"\\tr_prom:\" + repr(hist[1])\n			+ \"\\tr_0:\" + repr(r_0) + \"\\tr_max:\" + repr(hist[2]))\n\n	# adj = CalcAdjs1(N,dists,r_0) #calcula adjacencias con r_0\n	adj = CalcAdjs1(N,dists,hist[1]) #calcula adjacencias con r_prom\n	# adj = CalcAdjs1(N,dists,hist[1]) #calcula adjacencias con r_max\n	\n	# adj = CalcAdjs(dists,r_0) #calcula adjacencias con r_0\n	# adj = CalcAdjs(dists,hist[1]) #calcula adjacencias con r_prom\n	# adj = CalcAdjs(dists,hist[2]) #calcula adjacencias con r_max\n	# PrintAdjs(adj)\n\n	# print(sum(hist[0]))\n	# print(hist[1:4])\n\n	clusters = Cluster(adj)\n	# print(clusters[1])\n\n	# print(\"mas grande:\")\n	# print(clusters[2]/N)\n\n	max_cls.append(clusters[2]/N)\n\n	pylab.plot(bin_vec,hist[0])\n	# pylab.plot(hist[4]*bin_vec,hist[0])\n	# pylab.plot(hist[6],hist[0])\n\n	cls_data.write(repr(j) + \"\\t\" + repr(clusters[2]/N) + \"\\n\")\n\npylab.savefig(img_path+\"/graficas_distribucion/dist_\"+str(f)+\".png\")\n\ncls_data.close()\n\n# print(max_cls)\n# pylab.plot(tiempo,max_cls)\n# pylab.savefig(img_path+\"cluster_t_\"+str(f)+\".png\")\n",
			"file": "/home/martin/GitRepos/JuliaFlocks/PyData/Stats.py",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 3067,
>>>>>>> FETCH_HEAD
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/C# Compile & Run/CSharpSingleFileBuild.sublime-build",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
			[
				"pacl",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Install Package"
			]
		],
		"width": 593.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/martinzh/GitRepos/Flock2D/lib/Flock2D/flock_def.cs",
		"/Users/martinzh/GitRepos/Flock2D/lib/Agent2D/agent_def.cs",
		"/Users/martinzh/GitRepos/Flock2D/lib/Vector2D/vector.cs",
		"/Users/martinzh/GitRepos/Flock2D/lib/PrintMethods/printing.cs",
		"/Users/martinzh/GitRepos/Flock2D/Flock2D/sim_flock_2d.cs",
		"/Users/martinzh/Documents/laboratorio/graphs.gp",
		"/Users/martinzh/Documents/laboratorio/freq_dep 05_6feb.txt",
		"/Users/martinzh/Documents/laboratorio/freq_dep.txt",
		"/Users/martinzh/Documents/laboratorio/intensity_fliter_35.dat",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/Flock2D/bin/Debug/sript_bash.py",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/Flock2D/bin/Debug/corridas.sh",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/lib/Agent2D/agent_def.cs",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/Flock2D/sim_flock_2d.cs",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/lib/PrintMethods/printing.cs",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/lib/Flock2D/flock_def.cs",
		"/home/martin/FLOCKS/flock2D_mono/Flock2D/Flock2D/bin/Debug/Flock2D.dll",
		"/home/martin/FLOCKS/flockc3D/swarm_3d.cs",
		"/home/martin/FLOCKS/flockc3D/log_scripts/graf.gp",
		"/home/martin/FLOCKS/flockc3D/log_scripts/dist_script.py",
		"/home/martin/FLOCKS/flockc3D/log_scripts/script.py",
		"/home/martin/FLOCKS/flockc3D/vector2D_class_def.cs",
		"/home/martin/FLOCKS/flockc3D/swarm_2d.cs",
		"/home/martin/FLOCKS/flockc3D/test.cs",
		"/home/martin/Documents/supercollider.txt",
		"/home/martin/Documents/Burocracia/motivacion_havana.txt",
		"/home/martin/FLOCKS/flockc3D/DefsSwarm.cs",
		"/home/martin/FLOCKS/flockc3D/log_scripts/plot_script.py",
		"/home/martin/FLOCKS/flockc3D/log_scripts/swarm_2d.cs",
		"/home/martin/FLOCKS/in_process/flocks.cs",
		"/home/martin/FLOCKS/in_process/quats_test.cs",
		"/home/martin/FLOCKS/in_process/quats.cs",
		"/home/martin/FLOCKS/visual/flock_3d/def_class_quaternion.pde",
		"/home/martin/FLOCKS/visual/flock_3d/def_class_agent.pde",
		"/home/martin/FLOCKS/visual/flock_2d/def_class_agent.pde",
		"/home/martin/FLOCKS/visual/flock_2d/flock_2d.pde",
		"/home/martin/FLOCKS/visual/flock_2d/def_class_flock.pde",
		"/home/martin/FLOCKS/in_process/log_scripts/script.py",
		"/media/martin/KINGSTON8GB/calc_pi.py",
		"/home/martin/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/martin/.config/sublime-text-3/Packages/Alignment/Default (Linux).sublime-keymap",
		"/home/martin/.config/sublime-text-3/Packages/User/C#.sublime-settings",
		"/home/martin/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/martin/.config/sublime-text-3/Packages/Alignment/Base File.sublime-settings",
		"/home/martin/FLOCKS/in_process/log_scripts/test.dat",
		"/home/martin/FLOCKS/in_process/log_scripts/graf.gp",
		"/home/martin/FLOCKS/in_process/log_scripts/plot_script.py",
		"/home/martin/FLOCKS/otro/Program.cs",
		"/home/martin/FLOCKS/test.cs",
		"/home/martin/sketchbook/bicis/test_mapa/test_mapa.pde",
		"/home/martin/sketchbook/bicis/mapa_ecobici/mapa_ecobici.pde",
		"/home/martin/.config/sublime-text-3/Packages/Default/Default (Linux).sublime-keymap",
		"/home/martin/sketchbook/bicis/mapa_ecobici/data/ecobiciestaciones.csv",
		"/home/martin/TERMITAS/sim_term/levy_test.cpp",
		"/home/martin/TERMITAS/sim_term/walkers_lib.h",
		"/home/martin/TERMITAS/sim_term/test.cpp",
		"/home/martin/TERMITAS/simulacion_c++/finales/sim_campo_pair.cpp",
		"/home/martin/TERMITAS/simulacion_c++/finales/prueba.cpp",
		"/home/martin/Dropbox/Public/Cursosy creditos",
		"/home/martin/CONCIERTOS"
	],
	"find":
	{
		"height": 22.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
<<<<<<< HEAD
			"distsFile",
			"this",
=======
			"dis",
			"double",
			"();\n",
			"parametros",
			"\";\n",
			"dat",
			".ToInt()",
			"params",
>>>>>>> FETCH_HEAD
			"0",
			"Console",
			"\"log_scripts",
			"//",
			" //",
			"vel",
			"Console",
			"t",
			"=============================================================================================\n",
			";\n",
			"psi_inst",
			"\":\" + str(2*i+2) +",
			"3",
			";\n",
			"d",
			"Agent",
			"agent",
			"Agent",
			"prom",
			"N",
			"prom",
			"N",
			"Vector3D",
			"this.",
			"this",
			"Vector3D",
			"Length",
			"4",
			"n",
			"10",
			"bottom",
			"boid",
			"PI/2",
			"-PI/2",
			"top",
			"tang_top",
			"ang",
			"n",
			"prom",
			"radius",
			"2D",
			"prom",
			"n",
			"ht",
			"= true",
			"go",
			"hg",
			"80,20",
			"dt",
			"pp",
			"100",
			"axis",
			"Agent2D",
			"3",
			"Agent2D",
			"0",
			"n",
			"this.",
			"ht",
			"N",
			"links",
			"Vector3D",
			"Double",
			"double",
			"ShowGeomLinks",
			");\n",
			"x",
			"V",
			"L",
			"N",
			"V",
			"L",
			"agent",
			"boid",
			"double",
			"public",
			"double",
			"rnd.NextSimDouble(1)",
			"Vector3D",
			"PVector",
			"vels",
			"this.",
			"= ",
			");\n",
			"h",
			"data",
			"this.",
			"Vector3D",
			"this",
			"v1",
			"this.",
			"Quaternion",
			"v1.x - v2.x,",
			"MyRand",
			"MyRand.NextSimDouble(1)",
			"MyRand.NextSimDouble(L)",
			"));\n",
			"2*V * rnd.NextDouble() - V",
			"2*L * rnd.NextDouble() - L",
			");\n",
			"v1",
			"--",
			"[-300:300]",
			"Align",
			"pos",
			"+ \":\" + str(3*i+1)",
			"script.write(data + \" using \" + str(3*i) + \":\" + str(3*i+1) + \" w lp, \\\\\\n\")",
			"left",
			"str",
			"Vector3D",
			"L",
			"Vector3D",
			"double[]",
			"//---------------------------------------//\n// Definicion de la clase\n//---------------------------------------//\n\npublic class Agent {\n\n	public double[] pos;\n	public double[] vel;\n	public int[] links;\n\n	// L --> tamanio de la caja (cubica) \n	// V --> vel maxima\n	// k --> numero de interacciones\n\n	public Agent(double L, double V, int k){\n\n		Random rnd = new Random();\n\n		double x = L*rnd.NextDouble()-L;\n		double y = L*rnd.NextDouble()-L;\n		double z = L*rnd.NextDouble()-L;\n\n		pos = new double[] {x,y,z};\n\n		// pos = new Vector3D(L*rnd.NextDouble()-L,L*rnd.NextDouble()-L,L*rnd.NextDouble()-L);\n\n		double vx = V*rnd.NextDouble()-V;\n		double vy = V*rnd.NextDouble()-V;\n		double vz = V*rnd.NextDouble()-V;\n\n		vel = new double[] {vx,vy,vz};\n\n		links = new int[k];\n\n	}\n}\n\n//---------------------------------------//\n",
			"float",
			"Vector3D",
			"\n//---------------------------------------//",
			"L*rnd.NextDouble()-L",
			"neigh",
<<<<<<< HEAD
			"float",
			"int",
			"<int,int>",
			"Sem. 1"
=======
			"float"
>>>>>>> FETCH_HEAD
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "StatsLib/StatsLib.cs",
					"semi_transient": false,
					"settings":
					{
<<<<<<< HEAD
						"buffer_size": 3428,
=======
<<<<<<< HEAD
						"buffer_size": 3075,
=======
						"buffer_size": 3304,
>>>>>>> FETCH_HEAD
>>>>>>> f76f9e0127aeb8ffc4e9ef0397f08c651e63291d
						"regions":
						{
						},
						"selection":
						[
							[
<<<<<<< HEAD
								117,
								117
=======
<<<<<<< HEAD
								2107,
								2107
=======
								2948,
								2948
>>>>>>> FETCH_HEAD
>>>>>>> f76f9e0127aeb8ffc4e9ef0397f08c651e63291d
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/C#.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
<<<<<<< HEAD
						"translation.y": 1305.0,
=======
<<<<<<< HEAD
						"translation.y": 1051.0,
=======
						"translation.y": 1215.0,
>>>>>>> FETCH_HEAD
>>>>>>> f76f9e0127aeb8ffc4e9ef0397f08c651e63291d
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "stat_test/Program.cs",
					"semi_transient": false,
					"settings":
					{
<<<<<<< HEAD
						"buffer_size": 2033,
=======
<<<<<<< HEAD
						"buffer_size": 1197,
=======
						"buffer_size": 2009,
>>>>>>> f76f9e0127aeb8ffc4e9ef0397f08c651e63291d
						"regions":
						{
						},
						"selection":
						[
							[
								1189,
								1189
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/C#.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 270.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "lib/PrintMethods/printing.cs",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5637,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/C#.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": -0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/home/martin/GitRepos/JuliaFlocks/PyData/LibData.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5530,
>>>>>>> FETCH_HEAD
						"regions":
						{
						},
						"selection":
						[
							[
<<<<<<< HEAD
								900,
								900
=======
								1931,
								1931
>>>>>>> FETCH_HEAD
							]
						],
						"settings":
						{
							"syntax": "Packages/C#/C#.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
<<<<<<< HEAD
						"translation.y": 0.0,
=======
						"translation.y": 1035.0,
>>>>>>> FETCH_HEAD
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
<<<<<<< HEAD
=======
				},
				{
					"buffer": 4,
					"file": "/home/martin/GitRepos/JuliaFlocks/PyData/Stats.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3067,
						"regions":
						{
						},
						"selection":
						[
							[
								1326,
								1326
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 270.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
>>>>>>> FETCH_HEAD
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 21.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.582775878906,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 176.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "flock2d.sublime-project",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
